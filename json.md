{
  "C++ Template": {
		"prefix": "boiler",
		"body": [
			"#include <bits/stdc++.h>",
			"#define nl (cout << endl)",
			"#define f(i,s,e) for(int i=s;i<e;i++)",
			"#define fr(i,s,e) for(int i=s;i>=e;i--)",
			"#define N 1000",
			"using namespace std;",
			"$1",
			"int main()",
			"{",
			"    $2", // Placeholder for the user to add content.
			"    return 0;",
			"}"
		],
		"description": "Template for a basic C++ program with standard libraries."
	},
  "ExpressionHandler": {
  "prefix": "exp",
  "body": [
    "class expressionHandler",
    "{",
    "    int precedence(char op)",
    "    {",
    "        if (op == '+' || op == '-') return 1;",
    "        if (op == '*' || op == '/') return 2;",
    "        return 0;",
    "    }",
    "",
    "    bool isOperator(char c)",
    "    {",
    "        return c == '+' || c == '-' || c == '*' || c == '/';",
    "    }",
    "",
    "public:",
    "    string infixToPostfix(string infix)",
    "    {",
    "        stack<char> ops;",
    "        string postfix = \"\";",
    "        int len = infix.length();",
    "        for (int i = 0; i < len; i++)",
    "        {",
    "            if (infix[i] == ' ') continue;",
    "            if (isdigit(infix[i]) || infix[i] == '.')",
    "            {",
    "                while (i < len && (isdigit(infix[i]) || infix[i] == '.'))",
    "                    postfix += infix[i++];",
    "                postfix += ' ';",
    "                i--;",
    "            }",
    "            else if (infix[i] == '(') ops.push('(');",
    "            else if (infix[i] == ')')",
    "            {",
    "                while (!ops.empty() && ops.top() != '(')",
    "                {",
    "                    postfix += ops.top(); postfix += ' '; ops.pop();",
    "                }",
    "                if (!ops.empty()) ops.pop();",
    "            }",
    "            else if (isOperator(infix[i]))",
    "            {",
    "                while (!ops.empty() && precedence(ops.top()) >= precedence(infix[i]))",
    "                {",
    "                    postfix += ops.top(); postfix += ' '; ops.pop();",
    "                }",
    "                ops.push(infix[i]);",
    "            }",
    "        }",
    "        while (!ops.empty()) { postfix += ops.top(); postfix += ' '; ops.pop(); }",
    "        return postfix;",
    "    }",
    "",
    "    double evaluatePostfix(string postfix) ",
    "    {",
    "        stack<double> st;",
    "        int len = postfix.length();",
    "        for (int i = 0; i < len; i++)",
    "        {",
    "            if (postfix[i] == ' ') continue;",
    "            if (isdigit(postfix[i]) || postfix[i] == '.')",
    "            {",
    "                string num = \"\";",
    "                while (i < len && (isdigit(postfix[i]) || postfix[i] == '.'))",
    "                    num += postfix[i++];",
    "                st.push(stod(num)); i--;",
    "            }",
    "            else if (isOperator(postfix[i]))",
    "            {",
    "                double b = st.top(); st.pop();",
    "                double a = st.top(); st.pop();",
    "                switch (postfix[i])",
    "                {",
    "                case '+': st.push(a + b); break;",
    "                case '-': st.push(a - b); break;",
    "                case '*': st.push(a * b); break;",
    "                case '/': st.push(a / b); break;",
    "                }",
    "            }",
    "        }",
    "        return st.top();",
    "    }",
    "",
    "    string infixToPrefix(string infix)",
    "    {",
    "        reverse(infix.begin(), infix.end());",
    "        for (int i = 0; i < infix.size(); i++)",
    "        {",
    "            if (infix[i] == '(') infix[i] = ')';",
    "            else if (infix[i] == ')') infix[i] = '(';",
    "        }",
    "        string postfix = infixToPostfix(infix);",
    "        vector<string> tokens;",
    "        string token = \"\";",
    "        for (char c : postfix)",
    "        {",
    "            if (c == ' ')",
    "            {",
    "                if (!token.empty()) tokens.push_back(token);",
    "                token.clear();",
    "            }",
    "            else token += c;",
    "        }",
    "        reverse(tokens.begin(), tokens.end());",
    "        string prefix = \"\";",
    "        for (auto &t : tokens) prefix += t + ' ';",
    "        return prefix;",
    "    }",
    "",
    "    double evaluatePrefix(string prefix)",
    "    {",
    "        stack<double> st;",
    "        vector<string> tokens;",
    "        string token = \"\";",
    "        for (char c : prefix)",
    "        {",
    "            if (c == ' ')",
    "            {",
    "                if (!token.empty()) tokens.push_back(token);",
    "                token.clear();",
    "            }",
    "            else token += c;",
    "        }",
    "        reverse(tokens.begin(), tokens.end());",
    "        for (auto &t : tokens)",
    "        {",
    "            if (t == \"+\" || t == \"-\" || t == \"*\" || t == \"/\")",
    "            {",
    "                double a = st.top(); st.pop();",
    "                double b = st.top(); st.pop();",
    "                if (t == \"+\") st.push(a + b);",
    "                else if (t == \"-\") st.push(a - b);",
    "                else if (t == \"*\") st.push(a * b);",
    "                else if (t == \"/\") st.push(a / b);",
    "            }",
    "            else st.push(stod(t));",
    "        }",
    "        return st.top();",
    "    }",
    "};"
  ],
  "description": "ExpressionHandler"
},
"BinarySearchTree": {
  "prefix": "bst",
  "body": [
    "struct BstNode",
    "{",
    "    int val;",
    "    BstNode *left = nullptr;",
    "    BstNode *right = nullptr;",
    "    BstNode(int val) : val(val) {};",
    "};",
    "",
    "class BST",
    "{",
    "    BstNode *root;",
    "    int N;",
    "",
    "    BstNode* insert(BstNode *&root, int val)",
    "    {",
    "        if (!root)",
    "            root = new BstNode(val), N++;",
    "        else if (root->val > val)",
    "            root->left = insert(root->left, val);",
    "        else",
    "            root->right = insert(root->right, val);    ",
    "        return root;",
    "    }",
    "    ",
    "    void preOrder(BstNode *root)",
    "    {",
    "        if (!root)",
    "            return;",
    "        cout << root->val << \" \";",
    "        if (root->left)",
    "            preOrder(root->left);",
    "        if (root->right)",
    "            preOrder(root->right);",
    "    }",
    "",
    "    void inOrder(BstNode *root)",
    "    {",
    "        if (!root)",
    "            return;",
    "        if (root->left)",
    "            inOrder(root->left);",
    "        cout << root->val << \" \";",
    "        if (root->right)",
    "            inOrder(root->right);",
    "    }",
    "",
    "    void postOrder(BstNode *root)",
    "    {",
    "        if (!root)",
    "            return;",
    "        if (root->left)",
    "            postOrder(root->left);",
    "        if (root->right)",
    "            postOrder(root->right);",
    "        cout << root->val << \" \";",
    "    }",
    "",
    "    bool search(BstNode *root, int val)",
    "    {",
    "        if(!root) return false;",
    "        if(val < root->val) return search(root->left, val);",
    "        else if(val > root->val) return search(root->right, val);",
    "        return true;",
    "    }",
    "",
    "    BstNode* getSuccessor(BstNode* cur) {",
    "        cur = cur->right;",
    "        while (cur != nullptr && cur->left != nullptr)",
    "            cur = cur->left;",
    "        return cur;",
    "    }",
    "",
    "    BstNode* deleteNode(BstNode* root, int val){",
    "        if(!root) return root;",
    "        if(val < root->val) root->left = deleteNode(root->left, val);",
    "        else if(val > root->val) root->right = deleteNode(root->right, val);",
    "        else{",
    "            if (root->left == nullptr) {",
    "                BstNode* temp = root->right;",
    "                delete root;",
    "                return temp;",
    "            }",
    "            if (root->right == nullptr) {",
    "                BstNode* temp = root->left;",
    "                delete root;",
    "                return temp;",
    "            }",
    "            BstNode* succ = getSuccessor(root);",
    "            root->val = succ->val;",
    "            root->right = deleteNode(root->right, succ->val);",
    "        }",
    "        return root;",
    "    }",
    "",
    "public:",
    "    BST(BstNode *root = nullptr) : root(root), N(0) {}",
    "",
    "    void insert(int val) { insert(root, val); }",
    "    void preOrder() { preOrder(root); }",
    "    void inOrder() { inOrder(root); }",
    "    void postOrder() { preOrder(root); }",
    "    bool search(int val) { return search(root, val); }",
    "    void deleteNode(int val) { deleteNode(root, val);}",
    "};"
  ],
  "description": "BinarySearchTree"
},
"AdelsonVelskyLandis": {
  "prefix": "avl",
  "body": [
    "struct BstNode",
    "{",
    "    int data;",
    "    BstNode *left;",
    "    BstNode *right;",
    "    int height;",
    "",
    "    BstNode(int val)",
    "    {",
    "        data = val;",
    "        left = right = NULL;",
    "        height = 1;",
    "    }",
    "};",
    "",
    "class AVL",
    "{",
    "    BstNode *root;",
    "",
    "    int get_height(BstNode *node)",
    "    {",
    "        if (node == NULL)",
    "            return 0;",
    "        return node->height;",
    "    }",
    "",
    "    int get_balance(BstNode *node)",
    "    {",
    "        if (node == NULL)",
    "            return 0;",
    "        return get_height(node->left) - get_height(node->right);",
    "    }",
    "",
    "    void update_height(BstNode *node)",
    "    {",
    "        int l_h = get_height(node->left);",
    "        int r_h = get_height(node->right);",
    "",
    "        node->height = 1 + max(l_h, r_h);",
    "    }",
    "",
    "    // Right Rotation",
    "    BstNode *rotate_right(BstNode *y)",
    "    {",
    "        BstNode *x = y->left;",
    "        BstNode *T2 = x->right;",
    "",
    "        x->right = y;",
    "        y->left = T2;",
    "",
    "        update_height(y);",
    "        update_height(x);",
    "",
    "        return x;",
    "    }",
    "",
    "    // Left Rotation",
    "    BstNode *rotate_left(BstNode *x)",
    "    {",
    "        BstNode *y = x->right;",
    "        BstNode *T2 = y->left;",
    "",
    "        y->left = x;",
    "        x->right = T2;",
    "",
    "        update_height(x);",
    "        update_height(y);",
    "",
    "        return y;",
    "    }",
    "",
    "    BstNode *balance_node(BstNode *node)",
    "    {",
    "        int balance = get_balance(node);",
    "",
    "        // Left Left Case",
    "        if (balance > 1 && get_balance(node->left) >= 0)",
    "            return rotate_right(node);",
    "",
    "        // Left Right Case",
    "        if (balance > 1 && get_balance(node->left) < 0)",
    "        {",
    "            node->left = rotate_left(node->left);",
    "            return rotate_right(node);",
    "        }",
    "",
    "        // Right Right Case",
    "        if (balance < -1 && get_balance(node->right) <= 0)",
    "            return rotate_left(node);",
    "",
    "        // Right Left Case",
    "        if (balance < -1 && get_balance(node->right) > 0)",
    "        {",
    "            node->right = rotate_right(node->right);",
    "            return rotate_left(node);",
    "        }",
    "",
    "        // Already balanced",
    "        return node;",
    "    }",
    "",
    "    // Insert with AVL balancing",
    "    BstNode *insert(BstNode *node, int val)",
    "    {",
    "        if (node == NULL)",
    "            return new BstNode(val);",
    "",
    "        if (val < node->data)",
    "            node->left = insert(node->left, val);",
    "        else if (val > node->data)",
    "            node->right = insert(node->right, val);",
    "        else",
    "            return node; // Duplicates not allowed",
    "",
    "        update_height(node);",
    "        return balance_node(node);",
    "    }",
    "",
    "    // Find node with minimum value",
    "    BstNode *find_min(BstNode *node)",
    "    {",
    "        while (node && node->left != NULL)",
    "            node = node->left;",
    "        return node;",
    "    }",
    "",
    "    // Delete node with AVL balancing",
    "    BstNode *delete_node(BstNode *node, int val)",
    "    {",
    "        if (node == NULL)",
    "            return node;",
    "",
    "        if (val < node->data)",
    "            node->left = delete_node(node->left, val);",
    "        else if (val > node->data)",
    "            node->right = delete_node(node->right, val);",
    "        else",
    "        {",
    "            if (node->left == NULL || node->right == NULL)",
    "            {",
    "                BstNode *temp = node->left ? node->left : node->right;",
    "",
    "                if (temp == NULL)",
    "                {",
    "                    temp = node;",
    "                    node = NULL;",
    "                }",
    "                else",
    "                    *node = *temp;",
    "",
    "                delete temp;",
    "            }",
    "            else",
    "            {",
    "                BstNode *temp = find_min(node->right);",
    "                node->data = temp->data;",
    "                node->right = delete_node(node->right, temp->data);",
    "            }",
    "        }",
    "",
    "        if (node == NULL)",
    "            return node;",
    "",
    "        update_height(node);",
    "        return balance_node(node);",
    "    }",
    "",
    "    // Inorder traversal",
    "    void inorder(BstNode *node)",
    "    {",
    "        if (node != NULL)",
    "        {",
    "            inorder(node->left);",
    "            cout << node->data << \" \";",
    "            inorder(node->right);",
    "        }",
    "    }",
    "",
    "public:",
    "    AVL()",
    "    {",
    "        root = NULL;",
    "    }",
    "",
    "    void insert(int val)",
    "    {",
    "        root = insert(root, val);",
    "    }",
    "",
    "    void remove(int val)",
    "    {",
    "        root = delete_node(root, val);",
    "    }",
    "",
    "    void display()",
    "    {",
    "        inorder(root);",
    "        cout << endl;",
    "    }",
    "};"
  ],
  "description": "AdelsonVelskyLandis"
},
"MaxHeap": {
  "prefix": "max",
  "body": [
    "class MaxHeap",
    "{",
    "    int heap[N];",
    "    int size;",
    "",
    "public:",
    "    MaxHeap() : size(0) {}",
    "",
    "    MaxHeap(int arr[], int s) : size(s)",
    "    {",
    "        for (int i = 0; i < size; i++)",
    "            heap[i] = arr[i];",
    "        heapify();",
    "    }",
    "",
    "    int left(int i)  { return 2 * i + 1; }",
    "    int right(int i) { return 2 * i + 2; }",
    "    int parent(int i){ return (i - 1) / 2; }",
    "    int getSize() { return size; }",
    "",
    "    void heapify()",
    "    {",
    "        if (size <= 1) return;",
    "        for (int i = parent(size - 1); i >= 0; i--)",
    "            heapifyDown(i);",
    "    }",
    "",
    "    void heapifyDown(int i)",
    "    {",
    "        int idx = i;",
    "        int l = left(i);",
    "        int r = right(i);",
    "",
    "        if (l < size && heap[l] > heap[idx]) idx = l;",
    "        if (r < size && heap[r] > heap[idx]) idx = r;",
    "",
    "        if (idx != i)",
    "        {",
    "            swap(heap[i], heap[idx]);",
    "            heapifyDown(idx);",
    "        }",
    "    }",
    "",
    "    void heapifyUp(int i)",
    "    {",
    "        while (i > 0 && heap[i] > heap[parent(i)])",
    "        {",
    "            swap(heap[i], heap[parent(i)]);",
    "            i = parent(i);",
    "        }",
    "    }",
    "",
    "    bool empty() { return size == 0; }",
    "",
    "    void insert(int val)",
    "    {",
    "        if (size >= N) return;",
    "        heap[size] = val;",
    "        heapifyUp(size);",
    "        size++;",
    "    }",
    "",
    "    void update(int i, int newVal)",
    "    {",
    "        if (i >= 0 && i < size)",
    "        {",
    "            int oldVal = heap[i];",
    "            heap[i] = newVal;",
    "            if (newVal > oldVal)",
    "                heapifyUp(i);",
    "            else",
    "                heapifyDown(i);",
    "        }",
    "    }",
    "",
    "    int remove()",
    "    {",
    "        if (size == 0) return -1;",
    "",
    "        int root = heap[0];",
    "        heap[0] = heap[size - 1];",
    "        size--;",
    "        heapifyDown(0);",
    "",
    "        return root;",
    "    }",
    "    ",
    "    void print() {",
    "        for (int i = 0; i < size; i++)",
    "            cout << heap[i] << \" \";",
    "        cout << \"\\n\";",
    "    }",
    "};"
  ],
  "description": "MaxHeap"
},
"Hashing": {
  "prefix": "hashchain",
  "body": [
    "const int TABLE_SIZE = 10;",
    "",
    "",
    "struct Node {",
    "    int key;           ",
    "    string value;    ",
    "    Node* next;        ",
    "",
    "    Node(int k, const string& v) {",
    "        key = k;",
    "        value = v;",
    "        next = nullptr;",
    "    }",
    "};",
    "",
    "class HashTable {",
    "private:",
    "    Node* table[TABLE_SIZE];  ",
    "",
    "    int hashFunction(int key) {",
    "        return key % TABLE_SIZE;",
    "    }",
    "",
    "public:",
    "    HashTable() {",
    "        for (int i = 0; i < TABLE_SIZE; i++) {",
    "            table[i] = nullptr;",
    "        }",
    "    }",
    "",
    "    void insert(int key, const string& name) {",
    "        int index = hashFunction(key);",
    "",
    "        // Check if key already exists in the chain, update it",
    "        Node* current = table[index];",
    "        while (current != nullptr) {",
    "            if (current->key == key) {",
    "                current->value = name;  ",
    "                return;",
    "            }",
    "            current = current->next;",
    "        }",
    "        ",
    "        Node* newNode = new Node(key, name);",
    "        newNode->next = table[index];",
    "        table[index] = newNode;",
    "    }",
    "",
    "    string search(int key) {",
    "        int index = hashFunction(key);",
    "        Node* current = table[index];",
    "",
    "        while (current != nullptr) {",
    "            if (current->key == key) {",
    "                return current->value;",
    "            }",
    "            current = current->next;",
    "        }",
    "",
    "        return \"NOT FOUND\";",
    "    }",
    "",
    "",
    "    void remove(int key) {",
    "        int index = hashFunction(key);",
    "        Node* temp = table[index];",
    "        Node* prev = nullptr;",
    "",
    "        while (temp != nullptr && temp->key!=key) {",
    "            prev = temp;",
    "            temp = temp->next;",
    "        }",
    "        if(temp==nullptr){",
    "        	cout << \"Key \" << key << \" not found\\n\";",
    "		}",
    "        if (prev == nullptr) {",
    "            // Node is at head",
    "            table[index] = temp->next;",
    "        } ",
    "		else {",
    "            prev->next = temp->next;",
    "        }",
    "        delete temp;",
    "        cout << \"Key \" << key << \" deleted\\n\";",
    "    }",
    "",
    "    void display() {",
    "        for (int i = 0; i < TABLE_SIZE; i++) {",
    "            cout << \"Index \" << i << \" : \";",
    "            Node* current = table[i];",
    "            if (!current) {",
    "                cout << \"EMPTY\";",
    "            }",
    "            while (current != nullptr) {",
    "                cout << \" -> [Key: \" << current->key",
    "                     << \", Name: \" << current->value << \"]\";",
    "                current = current->next;",
    "            }",
    "            cout << endl;",
    "        }",
    "    }",
    "",
    "    ~HashTable() {",
    "        for (int i = 0; i < TABLE_SIZE; i++) {",
    "            Node* current = table[i];",
    "            while (current != nullptr) {",
    "                Node* temp = current;",
    "                current = current->next;",
    "                delete temp;",
    "            }",
    "        }",
    "    }",
    "};"
  ],
  "description": "Hashing"
},

"Hashing": {
  "prefix": "hashprob",
  "body": [
    "const int TABLE_SIZE = 10;",
    "",
    "class HashTable {",
    "private:",
    "    int keys[TABLE_SIZE];        ",
    "    string values[TABLE_SIZE];   ",
    "    bool occupied[TABLE_SIZE];   ",
    "",
    "    int hashFunction(int key) {",
    "        return key % TABLE_SIZE;",
    "    }",
    "",
    "public:",
    "    HashTable() {",
    "        for (int i = 0; i < TABLE_SIZE; i++) {",
    "            occupied[i] = false;",
    "            keys[i] = 0;",
    "            values[i] = \"\";",
    "        }",
    "    }",
    "",
    "    void insert(int key, const string& name) {",
    "        int index = hashFunction(key);",
    "        int startIndex = index; ",
    "",
    "        while (occupied[index]) {",
    "            // If same key, update value",
    "            if (keys[index] == key) {",
    "                values[index] = name;",
    "                return;",
    "            }",
    "",
    "            // Move to next index (linear probing)",
    "            index = (index + 1) % TABLE_SIZE;",
    "",
    "            if (index == startIndex) {",
    "                cout << \"Hash table is full, cannot insert key \" << key << endl;",
    "                return;",
    "            }",
    "        }",
    "",
    "        // Found an empty slot",
    "        keys[index] = key;",
    "        values[index] = name;",
    "        occupied[index] = true;",
    "    }",
    "",
    "    string search(int key) {",
    "        int index = hashFunction(key);",
    "        int startIndex = index;",
    "",
    "        while (occupied[index]) {",
    "            if (keys[index] == key) {",
    "                return values[index];   ",
    "            }",
    "",
    "            index = (index + 1) % TABLE_SIZE;",
    "",
    "            if (index == startIndex) {",
    "                break;",
    "            }",
    "        }",
    "",
    "        return \"NOT FOUND\";",
    "    }",
    "",
    "    void display() {",
    "        cout << \"Index\\tKey\\tName\\n\";",
    "        for (int i = 0; i < TABLE_SIZE; i++) {",
    "            if (occupied[i]) {",
    "                cout << i << \"\\t\" << keys[i] << \"\\t\" << values[i] << \"\\n\";",
    "            } else {",
    "                cout << i << \"\\t\" << \"-\\t\" << \"-\\n\";",
    "            }",
    "        }",
    "    }",
    "};"
  ],
  "description": "Hashing"
},
"Hashing": {
  "prefix": "hashtwice",
  "body": [
    "const int TABLE_SIZE = 10;",
    "",
    "class HashTable {",
    "private:",
    "    int keys[TABLE_SIZE];",
    "    string values[TABLE_SIZE];",
    "    bool occupied[TABLE_SIZE];",
    "",
    "    // Primary hash",
    "    int hash1(int key) {",
    "        return key % TABLE_SIZE;",
    "    }",
    "",
    "    // Secondary hash (step size), must be non-zero",
    "    int hash2(int key) {",
    "        int R = 7; // prime smaller than TABLE_SIZE",
    "        return R - (key % R);",
    "    }",
    "",
    "public:",
    "    HashTable() {",
    "        for (int i = 0; i < TABLE_SIZE; i++) {",
    "            keys[i] = 0;",
    "            values[i] = \"\";",
    "            occupied[i] = false;",
    "        }",
    "    }",
    "",
    "    void insert(int key, const string& name) {",
    "        int h1 = hash1(key);",
    "        int h2 = hash2(key);",
    "        int index;",
    "        int i = 0;",
    "",
    "        while (i < TABLE_SIZE) {",
    "            index = (h1 + i * h2) % TABLE_SIZE;",
    "",
    "            if (!occupied[index] || keys[index] == key) {",
    "                keys[index] = key;",
    "                values[index] = name;",
    "                occupied[index] = true;",
    "                return;",
    "            }",
    "",
    "            i++;",
    "        }",
    "",
    "        cout << \"Hash table full, cannot insert key \" << key << endl;",
    "    }",
    "",
    "    string search(int key) {",
    "        int h1 = hash1(key);",
    "        int h2 = hash2(key);",
    "        int index;",
    "        int i = 0;",
    "",
    "        while (i < TABLE_SIZE) {",
    "            index = (h1 + i * h2) % TABLE_SIZE;",
    "",
    "            if (!occupied[index]) return \"NOT FOUND\";",
    "            if (keys[index] == key) return values[index];",
    "",
    "            i++;",
    "        }",
    "",
    "        return \"NOT FOUND\";",
    "    }",
    "",
    "    void display() {",
    "        cout << \"Index\\tKey\\tName\\n\";",
    "        for (int i = 0; i < TABLE_SIZE; i++) {",
    "            if (occupied[i])",
    "                cout << i << \"\\t\" << keys[i] << \"\\t\" << values[i] << \"\\n\";",
    "            else",
    "                cout << i << \"\\t-\\t-\\n\";",
    "        }",
    "    }",
    "};"
  ],
  "description": "Hashing"
},

"Hashing": {
  "prefix": "rehash",
  "body": [
    "class HashTable",
    "{",
    "    int *table;",
    "    int capacity;",
    "    int count;",
    "",
    "public:",
    "    HashTable(int cap = 10)",
    "    {",
    "        capacity = cap;",
    "        count = 0;",
    "        table = new int[capacity];",
    "        for (int i = 0; i < capacity; i++)",
    "            table[i] = -1;",
    "    }",
    "",
    "    int hash(int key)",
    "    {",
    "        return key % capacity;",
    "    }",
    "",
    "    void insert(int key)",
    "    {",
    "        if ((float)count / capacity >= 0.7)",
    "            rehash();",
    "",
    "        int index = hash(key);",
    "        while (table[index] != -1)",
    "        {",
    "            index = (index + 1) % capacity;",
    "        }",
    "",
    "        table[index] = key;",
    "        count++;",
    "    }",
    "",
    "    void rehash()",
    "    {",
    "        int oldCapacity = capacity;",
    "        int *oldTable = table;",
    "",
    "        capacity = capacity * 2;",
    "        table = new int[capacity];",
    "        count = 0;",
    "",
    "        for (int i = 0; i < capacity; i++)",
    "            table[i] = -1;",
    "",
    "        for (int i = 0; i < oldCapacity; i++)",
    "        {",
    "            if (oldTable[i] != -1)",
    "                insert(oldTable[i]);",
    "        }",
    "",
    "        delete[] oldTable;",
    "    }",
    "",
    "    void print()",
    "    {",
    "        for (int i = 0; i < capacity; i++)",
    "        {",
    "            if (table[i] != -1)",
    "                cout << table[i] << \" \";",
    "            else",
    "                cout << \"_ \";",
    "        }",
    "        cout << \"\\n\";",
    "    }",
    "};"
  ],
  "description": "Hashing"
},

"Knuth Morris Pratt": {
  "prefix": "kmp",
  "body": [
    "bool kmp(string text, string pattern) {",
    "    int n = text.length();",
    "    int m = pattern.length();",
    "    ",
    "    if (m == 0) return true;",
    "    ",
    "    int pi[m];",
    "    pi[0] = 0;",
    "    ",
    "    for (int i = 1; i < m; i++) {",
    "        int j = pi[i - 1];",
    "        while (j > 0 && pattern[i] != pattern[j]) ",
    "            j = pi[j - 1];",
    "        if (pattern[i] == pattern[j]) ",
    "            j++;",
    "        pi[i] = j;",
    "    }",
    "",
    "    int j = 0;",
    "    for (int i = 0; i < n; i++) {",
    "        while (j > 0 && text[i] != pattern[j]) ",
    "            j = pi[j - 1];",
    "        if (text[i] == pattern[j]) ",
    "            j++;",
    "        if (j == m) ",
    "            return true;",
    "    }",
    "",
    "    return false;",
    "}"
  ],
  "description": "Knuth Morris Pratt"
}
"Choice per chor rha": {
  "prefix": "boyer",
  "body": [
    "#define NO_OF_CHARS 256",
    "",
    "void badCharHeuristic(string pattern, int badChar[]) {",
    "    f(i,0,NO_OF_CHARS) badChar[i] = -1;",
    "    f(i,0,pattern.length()) badChar[(int)pattern[i]] = i;",
    "}",
    "",
    "void boyerMooreSearch(string text, string pattern) {",
    "    int n = text.length();",
    "    int m = pattern.length();",
    "    int badChar[NO_OF_CHARS];",
    "    badCharHeuristic(pattern, badChar);",
    "",
    "    int s = 0;",
    "    while(s <= n - m) {",
    "        int j = m - 1;",
    "        while(j >= 0 && pattern[j] == text[s + j]) j--;",
    "        if(j < 0) {",
    "            cout << \"Pattern found at index \" << s << endl;",
    "            s += (s + m < n) ? m - badChar[(int)text[s + m]] : 1;",
    "        } else {",
    "            int shift = max(1, j - badChar[(int)text[s + j]]);",
    "            s += shift;",
    "        }",
    "    }",
    "}"
  ],
  "description": "Choice per chor rha"
}
}
